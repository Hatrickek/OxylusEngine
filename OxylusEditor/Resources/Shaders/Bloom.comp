#version 460 core
#define EPSILON 0.0001
#define DOWNSAMPLE_STAGE 0
#define UPSAMPLE_STAGE 1

#extension GL_EXT_nonuniform_qualifier : require

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0) restrict writeonly uniform image2D ImgResult[]; //0: Downsampled, 1: Upsampled
layout(set = 1, binding = 0) uniform sampler2D Samplers[]; //0: PBR Image, 1: Downscaled, 2: Upsampled 

layout(push_constant) uniform uPC {
  int UnitIndex, DownsamplerIndex, UpsamplerIndex;
}
u_PC;

layout(set = 2, binding = 0) uniform UBO {
  vec4 Params; // x: threshold, y: clamp, z: radius, w: unused
  ivec2 Stage; //x: Stage, y: Lod
}
u_Ubo;

vec3 Downsample(sampler2D srcTexture, vec2 uv, float lod);
vec3 Upsample(sampler2D srcTexture, vec2 uv, float lod);
vec3 Prefilter(vec3 color);

void main() {
  ivec2 imgCoord = ivec2(gl_GlobalInvocationID.xy);
  ivec2 imgSize = imageSize(ImgResult[u_PC.UnitIndex]);
  if (any(greaterThanEqual(imgCoord, imgSize)))
    return;

  vec3 result = vec3(0.0);
  vec2 uv = (imgCoord + 0.5) / imgSize;

  if (u_Ubo.Stage.x == DOWNSAMPLE_STAGE) {
    result = Downsample(Samplers[u_PC.DownsamplerIndex], uv, u_Ubo.Stage.y);
    if (u_Ubo.Stage.y == 0) {
      result = Prefilter(result);
    }
  } else if (u_Ubo.Stage.x == UPSAMPLE_STAGE) {
    result = Upsample(Samplers[u_PC.UpsamplerIndex], uv, u_Ubo.Stage.y) +
             textureLod(Samplers[u_PC.DownsamplerIndex], uv, u_Ubo.Stage.y).rgb;
  }
  // writes to Lod + 1 mip level when downsampling
  // writes to Lod - 1 mip level when upsampling
  imageStore(ImgResult[u_PC.UnitIndex], imgCoord, vec4(result, 1.0));
}

vec3 Downsample(sampler2D src, vec2 uv, float lod) {
  vec3 center = textureLod(src, uv, lod).rgb;
  vec3 yellowUpRight = textureLodOffset(src, uv, lod, ivec2(0, 2)).rgb;
  vec3 yellowDownLeft = textureLodOffset(src, uv, lod, ivec2(-2, 0)).rgb;
  vec3 greenDownRight = textureLodOffset(src, uv, lod, ivec2(2, 0)).rgb;
  vec3 blueDownLeft = textureLodOffset(src, uv, lod, ivec2(0, -2)).rgb;

  vec3 yellow = textureLodOffset(src, uv, lod, ivec2(-2, 2)).rgb;
  yellow += yellowUpRight;
  yellow += center;
  yellow += yellowDownLeft;

  vec3 green = yellowUpRight;
  green += textureLodOffset(src, uv, lod, ivec2(2, 2)).rgb;
  green += greenDownRight;
  green += center;

  vec3 blue = center;
  blue += greenDownRight;
  blue += textureLodOffset(src, uv, lod, ivec2(2, -2)).rgb;
  blue += blueDownLeft;

  vec3 lila = yellowDownLeft;
  lila += center;
  lila += blueDownLeft;
  lila += textureLodOffset(src, uv, lod, ivec2(-2, -2)).rgb;

  vec3 red = textureLodOffset(src, uv, lod, ivec2(-1, 1)).rgb;
  red += textureLodOffset(src, uv, lod, ivec2(1, 1)).rgb;
  red += textureLodOffset(src, uv, lod, ivec2(1, -1)).rgb;
  red += textureLodOffset(src, uv, lod, ivec2(-1, -1)).rgb;

  return (red * 0.5 + (yellow + green + blue + lila) * 0.125) * 0.25;
}

vec3 Upsample(sampler2D src, vec2 uv, float lod) {
  vec3 result = textureLodOffset(src, uv, lod, ivec2(-1.0, 1.0)).rgb * 1.0;
  result += textureLodOffset(src, uv, lod, ivec2(0.0, 1.0)).rgb * 2.0;
  result += textureLodOffset(src, uv, lod, ivec2(1.0, 1.0)).rgb * 1.0;

  result += textureLodOffset(src, uv, lod, ivec2(-1.0, 0.0)).rgb * 2.0;
  result += textureLod(src, uv, lod).rgb * 4.0;
  result += textureLodOffset(src, uv, lod, ivec2(1.0, 0.0)).rgb * 2.0;

  result += textureLodOffset(src, uv, lod, ivec2(-1.0, -1.0)).rgb * 1.0;
  result += textureLodOffset(src, uv, lod, ivec2(0.0, -1.0)).rgb * 2.0;
  result += textureLodOffset(src, uv, lod, ivec2(1.0, -1.0)).rgb * 1.0;

  return result / 16.0;
}

vec3 Prefilter(vec3 color) {
  const float Knee = 0.2;
  color = min(vec3(u_Ubo.Params.y), color);

  float brightness = max(max(color.r, color.g), color.b);

  vec3 curve = vec3(u_Ubo.Params.x - Knee, Knee * 2.0, 0.25 / Knee);
  float rq = clamp(brightness - curve.x, 0.0, curve.y);
  rq = (rq * rq) * curve.z;
  color *= max(rq, brightness - u_Ubo.Params.x) / max(brightness, EPSILON);

  return color;
}
